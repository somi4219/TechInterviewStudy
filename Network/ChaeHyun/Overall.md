## OSI 7계층

<img width="721" height="364" alt="image" src="https://github.com/user-attachments/assets/80f8285e-a805-4d10-b701-3763ce8318fc" />


- 국제 표준화기구에서 여러 통신 업체들의 장비 호환성을 위해 발표 (1984)
- 계층을 나눈 이유: 통신이 일어나는 과정이 단계별로 파악할 수 있기 때문

### Layer 1. 물리계층 (Physical Layer)

> 데이터를 전기 신호로 바꾸어주는 계층
> 
- 최하위 계층
- 0과 1의 `비트`열 → On, Off의 전기적 신호 상태로 데이터 전달
- PDU : 비트(Bit)
- 프로토콜 : Modem, Cable, Fiber, RS-232C
- 장비 : 허브, 리피터

### Layer 2. 데이터링크 계층 (Data-Link Layer)

> 데이터의 물리적인 전송과 에러 검출, 흐름 제어를 담당하는 계층
> 
- 물리적인 연결을 통하여 인접한 두 장치 간의 신뢰성 있는 정보 전송을 담당
- 통신에서의 오류도 찾아주고, 오류가 있다면 데이터를 재전송하는 기능
- Point-To-Point 전송
- MAC 주소 통해서 통신
- PDU : 프레임(Frame)
- 프로토콜 : 이더넷, MAC, PPP, ATM, LAN, Wifi
- 장비 : 브릿지, 스위치

### Layer 3. 네트워크 계층 (Network Layer)

> 패킷을 목적지까지 가장 빠른 길로 전송하기 위한 계층
> 
- 중계 노드를 통하여 전송하는 경우 어떻게 중계할 것인가를 규정
- 라우팅 기능을 맡고 있는 계층
- 목적지까지 가장 안전하고 빠르게 데이터를 보내는 기능
    - 최적의 경로 설정 가능
- PDU : 패킷(Packet)
- 프로토콜 : IP, ICMP 등
- 장비 : 라우터, L3 스위치

### Layer 4. 전송 계층 (Transport Layer)

> 최종 수신 프로세스로 데이터의 전송을 담당하는 계층
> 
- 종단 간 신뢰성 있고 정확한 데이터 전송을 담당
- 송신자와 수신자 간의 신뢰성있고 효율적인 데이터를 전송하기 위하여 오류검출 및 복구, 흐름제어와 중복검사 등을 수행
- 쪼개져 있는 데이터들을 원래대로 합쳐서 보내는 역할을 담당
    - 송신측에서 받은 데이터가 수신측까지 손실 없이 전송되었는지 여부 확인
    - 데이터를 전송할 때 헤더에 송/수신지 포트번호를 포함하여 전송
- PDU : 세그먼트(Segment)
- 프로토콜 : TCP, UDP , ARP, RTP
- 장비 : 게이트웨이, L4 스위치

<aside>
💡

- TCP의 3-way Handshake & 4-way Handshake
    - 각 단계(SYN, ACK, FIN)의 의미와 상태(State) 변화
    - 더보기
        - 2-way가 아닌 3-way를 쓰는 이유: **'양쪽 모두' 상대방이 통신 준비가 되었다는 것을 확실히 보장**
            - 클라이언트가 ACK를 받자마자 죽어버렸거나, 혹은 맨 처음 보낸 SYN이 사실 아주 오래전에 보냈던, 네트워크에 갇혀있던 패킷(Zombie packet)일 수 있음
        - 연결(3-way)과 달리, 종료가 4-way인 이유: “데이터를 다 보냈는지” 양쪽이 따로따로 확인해야 하기 때문
            1. **Client -> Server (FIN):** 클라이언트가 "나 이제 보낼 데이터 없어. 끝낼래"
            2. **Server -> Client (ACK):** 서버가 "알겠어. 너가 끝내고 싶다는 건 잘 받았어"라고 일단 대답
                - 하지만 서버는 아직 클라이언트에게 보내야 할 데이터가 남아있을 수 있음
                (예: 클라이언트가 요청한 파일의 마지막 조각)
            3. *(...서버는 남은 데이터를 마저 전송합니다...)*
            4. **Server -> Client (FIN):** 서버가 남은 데이터를 다 보내고 "자, 이제 나도 보낼 거 다 보냈어. 나도 끝낼래"
            5. **Client -> Server (ACK):** 클라이언트가 "그래, 너도 끝났다는 거 알겠어. 진짜 종료하자"라고 마지막 확인
        - 3-way Handshake(연결)에서는 서버의 '승인(ACK)'과 '준비(SYN)'가 **동시에** 일어나도 되지만, 4-way Handshake(종료)에서는 서버의 '승인(ACK)'과 '진짜 종료(FIN)'가 **분리되어야 함**
- 흐름제어 (Flow Control) vs 혼잡제어(Congestion Control)
    - 슬라이딩 윈도우, 혼잡회피
    - 더보기
        - 흐름제어: 1:1 통신. 수신자를 걱정
            - "내가 너무 빨리 보내면, 수신자(서버)가 데이터를 미처 처리하지 못하고 버퍼가 넘쳐서 데이터가 유실(drop)되면 어떡하지?”
            - 슬라이딩 윈도우
                - 수신자(Receiver)가 송신자(Sender)에게 "나 지금 딱 이만큼만 받을 수 있어"라고 자신의 '버퍼(임시 저장 공간) 여유량'을 알려주는 방식
                - 작동 방식
                    1. 수신자는 데이터를 받을 때마다, 응답(ACK) 패킷에 자신의 '윈도우 크기'(`rwnd`, 예: 1000바이트 남음)를 담아 보냄
                    2. 송신자는 그 '윈도우 크기'를 확인하고, *ACK를 기다리지 않고도* 최대 1000바이트까지 데이터를 보낼 수 있음
                    3. 수신자가 데이터를 처리해서 버퍼를 비우면, "이제 500바이트 더 처리했어. 총 1500바이트 보내도 돼"라고 윈도우 크기를 업데이트
        - **혼잡 제어:** **N:N** 통신. **네트워크(Network)** 전체를 걱정
            - "나 말고도 수많은 컴퓨터가 데이터를 보내고 있는데, 다들 너무 많이 보내서 중간에 있는 라우터들이 뻗어버리면(혼잡) 어떡하지?"
            - 혼잡회피
                - 송신자가 스스로 네트워크 상태를 추측하며 전송 속도 조절
                - 작동 방식
                    1. **슬로우 스타트 (Slow Start):** 처음엔 속도를 아주 빠르게 (2배, 4배, 8배...) 올림 (지수적 증가)
                    2. **혼잡 회피 (Congestion Avoidance):** 그러다 특정 한계점에 도달하거나 패킷 유실이 감지되면, "어? 이쯤부터 위험한데?"라고 판단하고 이 단계로 들어섬
                    3. 이때부턴 속도를 아주 조심스럽게 (1, 2, 3...) 올림 (선형적 증가)
- DNS가 UDP를 사용하는 이유
    - TCP/UDP 차이
    - 더보기
        
        ![image.png](attachment:e829ce73-57cd-4911-93a0-97027c718884:image.png)
        
        - TCP(Transmission Control Protocol): 신뢰할 수 있는 프로토콜
            - 데이터를 보내기 전에 3-way handshake로 연결을 확인하고, 데이터가 순서대로 갔는지, 빠진 건 없는지 일일이 검사
            - 오류가 발생하거나 순서가 뒤바뀌면 다시 보냄
        - UDP(User Datagram Protocol): 빠른 프로토콜
            - 연결확인, 순서 보장, 재전송없음
            - 매우 빠르고 오버헤드 적음
        - UDP를 사용하는 경우 === 데이터가 유실돼도 괜찮은 서비스가 있나?
            - 데이터가 작고 단순
                - DNS
                - `google.com`의 IP를 묻는 질문은 매우 작음
                TCP로 3-way handshake를 하는 것보다, UDP로 그냥 묻고 답이 안 오면 *한 번 더 묻는* 것이 훨씬 빠름
            - '최신' 정보가 '완벽한' 정보보다 중요할 때
                - 실시간 스트리밍, 게임
                - 영상 통화 중에 1초 전 화면(패킷)이 유실됐을 경우 1초 전 화면은 버리고 지금 화면을 계속 받음
            - 금융권에서 UDP를 사용할까?
                - 주식 시세 정보
                    - TCP를 쓴다면
                    만약 패킷 1이 유실되면, TCP는 '10,000원'짜리 패킷 1을 *다시 받아올 때까지* 패킷 2의 처리를 멈춤
                    하지만 이미 '10,010원'으로 가격이 바뀐 마당에, 100ms 전의 가격은 쓸모없는 '과거' 데이터
                    - **UDP를 쓴다면**
                    패킷 1이 유실돼도 상관없이, '최신' 정보인 패킷 2 (10,010원)를 즉시 처리
                    ⇒ 속도가 생명인 시장 정보에서는 **'완벽함'보다 '최신성'이 중요**하기 때문에 UDP를 사용
                - 주식 매수/매도 주문은 TCP
                
                ⇒ 서비스의 성격에 따라 프로토콜 선택하기
                
</aside>

### Layer 5. 세션 계층 (Session Layer)

> 컴퓨터끼리 통신을 하기 위해 세션을 만드는 계층
> 
- 통신 장치 간 상호작용 및 동기화를 제공
- 연결 세션에서 데이터 교환과 에러 발생 시의 복구를 관리
- 네트워크상 양쪽 연결을 관리하고 연결을 지속
- 운영체제가 통신을 하기 위한 세션 확립/유지/중단 과정 해줌
- 프로토콜 : NetBIOS, SSH, TLS

<aside>
💡

- 동기화
- 더보기
    - 단ㅅ
</aside>

### Layer 6. 표현 계층 (Presentation Layer)

> 데이터 형식을 정의하는 계층 (코드 간의 번역)
> 
- 송신자에서 온 데이터를 해석하기 위한 응용계층 데이터 부호화, 변화 (인코딩)
- 수신자에서 데이터의 압축을 풀 수 있는 방식으로 된 데이터 압축
- 데이터의 암호화와 복호화 (디코딩)
    
    MIME 인코딩이나 암호화 등의 동작이 표현계층에서 이루어짐
    
    ex) EBCDIC로 인코딩된 파일을 ASCII로 인코딩된 파일로 바꿔줌
    
- 프로토콜 : JPG, MPEG, SMB, AFP

### Layer 7. 응용 계층 (Application Layer)

> 사용자에게 통신을 위한 서비스 제공. 인터페이스 역할
> 
- 응용 프로세스 간의 정보 교환을 담당
- 사용자에게 보이는 유일한 계층. 메일 전송, 인터넷 접속 등의 작업을 수행
- 프로토콜 : DHCP, DNS, FTP, HTTP

<aside>
💡

- HTTP vs HTTPS
    - SSL/TLS 핸드셰이크 과정. 대칭키, 비대칭키가 어떻게 사용되는지
    - 더보기
        
        
- HTTP 메서드
    - 멱등성
- HTTP 1.1 vs 2.0 vs 3.0
    - HOL Blocking
    - HTTP 3.0이 왜 UDP를 사용했는지
    - 더보기
        - HTTP 1.1
            - TCP 연결 하나로 여러 요청을 보낼 수 있지만 응답은 순차적으로
            - 문제점 L7 HOL Blocking
                - css 파일 요청 → js 파일 요청
                - css느려지면 js가 준비가되어도 css 응답이 올 때까지 막힘
                
                ⇒ HTTP 파이프라이닝
                
                - 브라우저가 도메인당 6~8개의 TCP 연결을 동시에 맺어서 문제 회피
        - HTTP 2.0
            - 하나의 TCP 연결 위에서 여러개의 스트림
            - 데이터가 멀티플렉싱되어 순서에 상관없이 응답받을 수 있음
            - 개선점
                - css, js, jpg 동시에 요청하고 jpg가 먼저 준비되면 순서 상관없이 받을 수 있음
                    
                    ⇒ L7 HOL Blocing 해결
                    
            - 남은 문제 TCP HOL Blocking
                - TCP는 패킷 순서를 보장해야 하므로 css 패킷 하나가 유실되면 커널 단에서 js, jpg 패킷이 이미 도착했음에도 불구하고 css 패킷이 재전송될 때까지 모든 스트림을 막음
        - HTTP 3.0
            - TCP 한계를 극복하기 위해 UDP 기반의 QUIC 프로토콜 위에서 동작
            - TCP의 신뢰성(순서보장, 재전송) 기능을 애플리케이션 레벨에서 직접 구현
            - TCP HOL Blocking 해결
                - 각 스트림이 독립적인 QUIC 스트림으로 매핑
                - css UDP 패킷이 유실되어도 js와 jpg 스트림은 막히지 않고 즉시 처리
</aside>

## TCP/IP 모델

- 인터넷 프로토콜 스택은 대부분 TCP/IP를 ㄸ름
- 인터넷 프로토콜 중 가장 중요한 역할을 하는 `TCP`와 `IP`의 합성어로 데이터의 흐름 관리, 정확성 확인, 패킷의 목적지 보장을 담당
- **데이터의 정확성 확인은 TCP가, 패킷을 목적지까지 전송하는 일은 IP가 담당**

![image.png](attachment:862c386a-eee8-4fe1-b6d4-6367d4354a91:image.png)

- 데이터 캡슐화
    - 단계별로 헤더(Data **→** Segment **→** Datagram **→** Frame)를 붙여 전송
    
    ![image.png](attachment:8501c854-1bd7-4cfa-8039-43257a894107:image.png)
    

## [www.google.com](http://www.google.com) 시나리오

> 브라우저 주소창에 [www.google.com](https://www.google.com/)을 입력하고 엔터를 쳤을 때 일어나는 일
**DNS**(L7) -> **HTTP**(L7) -> **TCP**(L4) -> **IP**(L3) -> **MAC**(L2)으로 이어지는 전 과정
> 

![image.png](attachment:259c8ef2-9148-4378-9d13-9d8a6f280fc0:image.png)

### L7. DNS - 이름 해석

- 상황: 브라우저는 `www.google.com`이라는 *이름*은 알지만, 실제 통신을 위한 *IP 주소* (예: `172.217.14.228`)는 모르고 있음
- 액션
    1. 브라우저가 자신의 로컬 캐시를 확인
    2. 없으면 OS에게 물어봄 → OS도 자체 캐시를 확인 (hosts 파일 등)
    3. 없으면 OS는 로컬 DNS 리졸버에게 "[www.google.com](https://www.google.com/)의 IP 주소 알려줘"라고 쿼리를 보냄
    4. 리졸버는 쿼리를 받아 캐시가 없다면
    Root DNS 서버부터 시작해서 .com을 관리하는 TLD 서버, google.com을 관리하는 신뢰할 수 있는 네임 서버까지 차례로 물어보는 **재귀적 쿼리(Recursive Query)**를 실행
- 결과: 리졸버가 [google.com](http://google.com) 의 IP 주소를 알아내서 브라우저에게 전달

**⇒ 브라우저는 목적지 IP 주소를 알게 됨!!!**

### L4. TCP 3-Way Handshake - 전화걸기

- 상황: IP 주소는 알지만, HTTP 요청이라는 데이터를 보내기 전에 먼저 서버와 안정적인 ‘통신 회선’을 열어야 함 → 이 역할을 TCP가 함
- 액션: 브라우저(클라이언트)가 구글 서버로 3-Way Handshake 시작
    1. Client → Server: “연결하고 싶어” (SYN 패킷 전송)
    2. Server → Client: “준비됐어” (SYN+ACK 패킷 응답)
    3. Client → Server: “시작하자” (ACK 패킷 전송)
- 결과: 양측 간에 신뢰할 수 있는 TCP연결(세션)이 수립

### L7. HTTP - 용건 말하기

- 상황: 안정적인 회선(TCP)이 열림. 브라우저는 이 회선을 통해 “구글 홈페이지 보여줘”라는 실제 요청을 보냄
- 액션
    
    브라우저가 다음과 같은 HTTP 요청 메시지
    
    ```jsx
    GET / HTTP/1.1
    Host: www.google.com
    User-Agent: (브라우저 정보...)
    ... (기타 헤더들)
    ```
    

### L4 → L3 → L2. 캡슐화 - 데이터 포장

- 상황: HTTP 요청 데이터를 목적지(구글 서버)로 보내야 함. 각 계층을 내려가면서 포장
- 액션
    1. **(L4) 전송 계층:** HTTP 메시지(데이터)는 **TCP 세그먼트**로 쪼개지고, 여기에 **TCP 헤더**가 붙음
    (여기에는 출발지/목적지 *포트 번호*가 포함됨. HTTP는 보통 80, HTTPS는 443번 포트)
    2. **(L3) 네트워크 계층:** TCP 세그먼트는 **IP 패킷**으로 포장디고 여기에 **IP 헤더**가 붙음
    (여기에는 출발지 IP와 1단계에서 알아낸 목적지 *IP 주소*가 포함됩니다.)
    3. **(L2) 데이터링크 계층:** IP 패킷은 **이더넷 프레임**으로 포장되고 여기에 **이더넷 헤더**가 붙음 
    (여기에는 출발지 MAC과 목적지 *MAC 주소*가 포함됩니다.)

<aside>
💡

**`ARP (Address Resolution Protocol)`**

> L3에서 목적지 IP 주소는 구글 서버의 최종주소.
> 
> 
> L2의 목적지 MAC 주소는 구글 서버의 MAC 주소가 아님.
> 
> IP 패킷을 인터넷으로 내보내기 위해 가장 먼저 전달해야 하는 기본 게이트웨이(라우터)의 MAC 주소가 필요함.
> 내 컴퓨터가 라우터의 MAC 주소를 알아내기 위해 사용하는 프로토콜은 무엇일까?
> 

- 컴퓨터는 기본 게이트웨이의 IP 주소는 알고있지만, 이더넷 프레임을 만들려면 그 라우터의 물리적인 MAC 주소가 필요함
    - ARP가 "192.168.0.1 IP 주소 가진 사람, MAC 주소 뭐야?”를 내부 네트워크(LAN)에 외침
    - 라우터가 “그거 난데, 내 MAC 주소는 [라우터 MAC 주소야]”라고 응답
- ARP의 역할 : IP 주소(L3)를 MAC주소(L2)로 변환
</aside>

### L1. 데이터 전송

- 상황: 모든 캡슐화가 끝난 이더넷 프레임이 준비됨
- 액션
    1. 이 프레임은 L1으로 전달
    2. 데이터(비트열)가 랜카드에 의해 전기 신호로 변환
    3. 랜선을 타고 라우터로 정송

### L3. 라우팅

- 상황: 내 컴퓨터가 보낸 프레임(전기 신호)이 라우터에 도착
- 액션
    1. 라우터는 L2(데이터링크 계층)의 장비이므로, 이더넷 프레임을 엶
    2. 라우터는 L3(네트워크 계층)의 장비이기도 하므로, 그 안의 IP 패킷을 엶
    3. IP 헤더에 적힌 **'최종 목적지 IP 주소'** (구글 서버 IP)를 확인
    4. 라우터는 자신이 가진 '라우팅 테이블'을 보고, 이 패킷을 구글 서버로 보내려면 그다음 어느 라우터로 보내야 할지 최적의 경로를 결정
    5. 라우터는 이 IP 패킷을 **새로운 L2 프레임으로 다시 포장**합니다. 
    (이때 출발지 MAC은 *내 라우터*, 목적지 MAC은 *인터넷상의 다음 라우터)*
- 결과: 인터넷의 수많은 라우터들을 거치며 반복

### L2~L7. 서버 도착 및 응답

- **상황:** 마침내 패킷이 구글 서버의 네트워크에 도착
- **액션:**
    1. 구글 서버는 받은 데이터를 L1 -> L2 -> L3 -> L4 -> L7 순서로 캡슐화를 품(역캡슐화).
    2. L7(응용 계층)에 도달하면, 드디어 "GET / HTTP/1.1 ..."라는 브라우저의 HTTP 요청을 읽음
    3. 서버는 이 요청에 맞는 응답(구글 홈페이지의 HTML, CSS, JavaScript 파일 등)을 준비
    4. 서버는 이 응답 데이터를 다시 **L7 -> L1 방향으로 캡슐화**
    (이번엔 서버가 출발지, 내 컴퓨터가 목적지)
    5. 이 응답 패킷이 인터넷 라우터들을 거쳐 다시 내 컴퓨터로 전송

### L7. 렌더링

- **상황:** 구글 서버가 보낸 응답 패킷이 내 컴퓨터에 도착
- **액션:**
    1. 내 컴퓨터도 L1 -> L7 순서로 역캡슐화를 진행
    2. L7(응용 계층)에서 브라우저가 HTTP 응답(HTML 등) 받음
    3. **렌더링 엔진**이 이 HTML을 해석해서 우리가 보는 `www.google.com` 웹페이지 화면을 그려줌

## Etc. 용어 정리

| **용어** | **설명** |
| --- | --- |
| **OSI 7계층** | 네트워크 통신 과정을 7단계(물리-데이터링크-네트워크-전송-세션-표현-응용)로 나눈 표준 모델 |
| **TCP/IP 4계층** | OSI 모델을 실제 인터넷 환경에 맞게 4단계(네트워크 액세스-인터넷-전송-응용)로 단순화한 실용 모델 |
| **TCP** | **신뢰성** 있는 데이터 전송을 보장하는 프로토콜
3-way handshake로 연결하고, 데이터 순서와 유실을 검사 `L4` |
| **UDP** | **속도**가 빠른 데이터 전송에 중점을 둔 프로토콜
신뢰성 보장(연결, 순서 검사) 과정을 생략 `L4` |
| **포트 (Port)** | IP 주소가 '아파트' 주소라면, 포트 번호는 '몇 동 몇 호'인지 알려주는 상세 주소 `L4` |
| **HTTP** | 웹 문서를 주고받는 규칙 `L7` |
| **HTTPS** | HTTP에 **보안(SSL/TLS 암호화)** 기능을 추가한 프로토콜 `L7` |
| **SSL/TLS** | HTTPS가 데이터를 안전하게 주고받을 수 있도록 암호화해주는 기술 |
| **GET vs. POST** | HTTP 요청 방식
GET은 주로 데이터를 *조회*할 때 (URL에 정보 노출)
POST는 데이터를 *생성/전송*할 때 (본문(Body)에 정보 숨김) |
| **흐름 제어** | **수신 측**이 처리할 수 있는 만큼만 **송신 측**이 데이터를 보내도록 속도를 조절하는 기술 `TCP` |
| **혼잡 제어** | **네트워크 전체**가 혼잡할 때, 데이터 전송량을 줄여서 네트워크 마비를 방지하는 기술입 `TCP` |
| **Gateway** | 서로 다른 프로토콜을 사용하는 네트워크 간의 '번역기' 및 '관문' 역할을 하는 장치
(라우터도 게이트웨이의 일종) |
| **DNS** | 도메인 이름(https://www.google.com/search?q=google.com)을 IP 주소로 변환 |
| **ARP** | IP 주소를 MAC 주소로 변환 |

https://medium.com/@heoh06/%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91-osi-7%EA%B3%84%EC%B8%B5-9f96b7cbcb7e

https://dev-coco.tistory.com/161

https://github.com/hyeong-jun-kim/CS-Study/blob/main/Network/OSI%207%EA%B3%84%EC%B8%B5.md

https://velog.io/@hidaehyunlee/%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B0%80-%EC%A0%84%EB%8B%AC%EB%90%98%EB%8A%94-%EC%9B%90%EB%A6%AC-OSI-7%EA%B3%84%EC%B8%B5-%EB%AA%A8%EB%8D%B8%EA%B3%BC-TCPIP-%EB%AA%A8%EB%8D%B8
