# 1. HTTP

Hyper Text : 다른 페이지의 링크를 담고 있는 문서

Transfer : 통신

Protocol : 규약

→ 서버(Backend)와 클라이언트(Frontend)가 서로 데이터를 주고받기 위해 사용되는 통신 규약

- HTTP/1.1, HTTP/2 : **TCP** 기반 → HTTP/3 : **UDP** 기반
    
    **why**⁉️ : TCP는 3 way handshake 등 처리 해야할 과정이 길어 신뢰성이나 연결성 보장되지만 속도가 떨어짐 → UDP로 재설계
    
    ( 하지만 아직 HTTP/1.1 널리 사용 )
    
- 특징
    
    ### 무상태성 ( Stateless )
    
    - 클라이언트-서버 간에 상태를 유지하지 않는다
        - 장점 : 서버 확장성 높음 ( **💡** 스케일 아웃  )
        - 단점 : 클라이언트가 추가 데이터 전송해야함 ( 메모리 사용량 up )
        
        > ⁉️ 홈페이지에서 회원 로그인을 하고 페이지를 옮기면 또 로그인해야함….!
        > 
        > 
        > ✅ 회원정보를 서버가 아니라 클라이언트가 토큰 형식으로 들고 있다가 서버랑 통신할 때 같이 보내서 인증받는 방식으로 해결
        > 
        > **( → 쿠키, 세션, 토큰 이용 )**
        > 
        
        ↔ 반대 : 상태유지( Stateful )
        
    
    ---
    
    **💡** 스케일 아웃 : 성능을 업그레이드 할때 서버를 여러대 추가하는 것
    
    ↔ 스케일 업 : 성능을 업그레이드 할때 기존 서버의 사양을 업그레이드 하는 것
    
    ---
    
    ### 비연결성 ( Connectionelss )
    
    - 클라이언트-서버 간에 연결을 지속하지 않는다
    - == 클라이언트가 요청한 걸 서버가 응답을 마치는 순간 연결 끊음
        
        > ⁉️ 왜 한번 맺은 연결을 끊을까?
        > 
        > 
        > ✅ 서버에서 다수의 클라이언트랑 연결하면 많은 리소스가 발생함. 응답 마치고 바로 끊으면 연결유지를 위한 리소스를 줄이고 그만큼 더 많은 연결을 할 수 있게 됨
        > 
        
        > → ⁉️ 하지만 연결을 매번 끊으니 요청 때마다 매번 새로운 연결을 해야하는 일 발생
        > 
        > 
        > **연결 해제에 대한 오버헤드가 발생**한다.
        > 
        > ### Keep Alive
        > 
        > ✅ 서버와 클라이언트가 상대방의 안부를 묻는 패킷을 주기적으로 보냄.
        > 
        > 패킷에 반응이 없으면 접속을 끊는 방법.
        > 
        > → ⁉️ 하지만, 서버가 바빠서 process가 늘어나는 경우는 keep alive를 유지하기 위한 메모리 또한 많아져 주의하며 사용해야함.
        > 
- 흐름
    1. TCP 연결을 열어준다. 
    2. HTTP 메시지 전송을 한다.
    3. 서버가 보낸 응답을 읽는다.
    4. 연결을 닫거나, 다른 요청을 위해 재사용한다.
    
- HTTP 메시지 구조

  <img src="https://velog.velcdn.com/images%2Fanhesu11%2Fpost%2Ff9934c03-a615-41ff-8862-219629fb0aee%2Fimage.png">
    
- HTTP 메서드
    
    == 요청과 응답 데이터를 전송하는 방식
    
    ( 주어진 리소스에 서버가 수행하길 원하는 행동을 지정해서 서버에 보내는 것 )
    
    ### 주요 메소드 5가지
    
    - GET : 리소스 요청
    - POST : 요청 데이터 처리 ( 등록 )
    - PUT : 리소스를 대체, 해당 리소스가 없으면 등록
    - PATCH : 리소스 일부 변경
    - DELETE : 리소스 삭제
    
    > **⁉️ GET vs POST**
    > 
    > 
    > GET의 경우 쿼리스트링 ( url 끝에 ?값 붙여서 보내는 파라미터 ) 를 통해 요청
    > 
    > POST의 경우 데이터를 body에 담아 전송함
    > 
    > → 데이터가 눈에 안보이고 GET보다 안전하다
    > 
    > → 또, 요청 메서드의 헤더에 content-type ( json 같은 답변의 형식 ) 표시해야함
    > 
    
    > **⁉️ PUT vs PATCH**
    > 
    > 
    > PUT은 전체 리소스를 교체
    > 
    > PATCH는 리소스의 일부만 수정
    > 
    > ✅ 사용자 관련 데이터 ( 이름, 이메일, 전화번호 … ) 등 여러 필드가 있을 때
    > 
    > 이것을 한번에 업데이트 하고자 한다면 PUT이 유리함
    > 
    > → PUT은 필드 전체의 값이 다 있어야함 ! 없으면 null로 대체 되어버림..
    > 
    > 하지만 필드 중 하나 ( 전화번호 )만 업데이트하고자 한다면 PATCH가 유리함
    > 
    > → PATCH는 바꿀 필드의 값만 있어도 됨
    > 
    > ( 다른 차이 중에 멱등성 어쩌고 저쩌고 . . .  . . .. . )
    > 

# 2. HTTPS

HTTP + Secure

HTTP 에서 모든 요청과 응답을 SSL , TLS를 사용해 암호화 시킨 것

### SSL ( Secure Sockets Layer : 보안 소켓 계층 )

: 전송된 데이터를 암호화하여 인터넷 연결 보안을 유지하는 기술

- SSL 인증서
    1. 통신 내용 노출 변경 방지
    2. 클라이언트가 접속하려는 서버가 신뢰가능한지
    3. SSL 통신에 사용할 공개키를 클라이언트에게 제공
- 대칭키 ( 암호화, 복호화 시에 같은 키 이용 )
- 비대칭키 = 공개키+개인키 ( 암호화할 때 공개키, 복호화할때 개인키 )

### TLS ( Transfer Layer Security : 전송 계층 보안)

최신 기술로 강력한 버전의 SSL

# 3. 쿠키, 세션 (+ 캐시)

위에서 언급했던 바와 같이 Stateless의 특징을 가진 HTTP로 인해 쿠키,세션 등이 필요함

### 쿠키

사용자가 어떤 사이트에 방문했을때, 서버에서 사용자의 컴퓨터에 저장하는 기록 정보 

→ HTTP 에서 정보를 클라이언트 PC에 저장했다가 필요할 때 꺼내씀

- 동작순서
    1. 클라이언트가 페이지에 접근
    2. 웹 서버가 쿠키 생성
    3. 쿠키에 정보를 담아서 HTTP 화면 보내줄 때 같이 클라이언트에게 보내줌
    4. 받은 쿠키는 클라이언트( 로컬 PC )가 저장하고 있다가 서버에 다시 요청할 때 요청에 같이 담아서 전송
        
        ( 동일 사이트 재방문시, PC에 해당 쿠키가 있는 경우, 요청 + 쿠키 전송 )
        

### 세션

일정 시간 동안 같은 사용자로부터 들어오는 요구들을 상태로 보고, 그 상태를 유지

( 일정 시간 = 사용자가 웹 브라우저를 통해 웹 서버에 접속~종료하는 시점까지 )

즉!! 방문자가 웹 서버에 접속해 있는 상태를 하나의 단위로 본 것 === 세션

- 동작순서
    1. 클라이언트가 페이지에 접근
    2. 서버는 접근한 클라이언트의 쿠키를 확인→ 해당 session-id 보냈는지 확인
        
        ( 이때 쿠키는 세션 쿠키 )
        
    
    3-1.session-id가 존재하지 않는 경우, 서버는 생성하여 클라이언트에게 보내줌
    
    1. 클라이언트는 session-id를 쿠키에 저장
    
    3-2.session-id가 존재하는 경우, 서버는 전달받은 session-id로 세션의 클라이언트 정보를 가지고 요청 처리 후 응답
    

### ✅ 쿠키 vs 세션

|  | 쿠키 | 세션 |
| --- | --- | --- |
| 저장위치 | 클라이언트 ( 서버 자원 전혀 사용 X ) | 서버 |
| **만료시점** | 쿠키 저장시 만료시점 설정 | 브라우저 종료 시 삭제 |
| 보안 | 비교적 취약 ( 로컬에 저장 ) | 안전 ( session id만 저장 ) |
| 속도 | 빠름 ( 쿠키에 정보가 있음 ) | 비교적 느림 ( 서버에 정보가 있음 ) |

### (+캐시)

: 웹 페이지의 요소를 저장하기 위한 임시 저장소

( ↔ 쿠키,세션은 정보를 저장 )

: 웹 페이지를 빠르게 렌더링 할 수 있도록 도와줌

( ↔ 쿠키,세션은 사용자의 인증을 도와줌 )

# 3+. 세션 기반, 토큰 기반 인증 ( + JWT )

인가 Authorization : 유저의 요청에 대한 권한을 확인 ( 글 수정 → 내 글만 가능 )

인증 Authentication : 유저가 누구인지 ( 로그인, 회원가입 )

### 세션(=서버 ) 기반 인증 방식

<img src="https://camo.githubusercontent.com/80a6112f013d03523290fb84f34efcced478401dc255e7003b75151599d8b3d8/68747470733a2f2f626c6f672e6b616b616f63646e2e6e65742f646e2f6265354846752f62747141735238694564682f726b39586e6f36586c5141776254574669474958496b2f696d672e706e67">
1. 사용자가 아이디와 비밀번호로 로그인
2. 서버 측 정보를 검증
3. 정보가 정확하면 session-id를 쿠키를 통해 보냄
4. 클라이언트가 요청할 때마다 서버의 session-id와 요청의 session-id가 일치한지 확인 ( → 인가 )
- 문제점
    - 서버 부하 : 서버에서 클라이언트의 상태를 유지해야해서 메모리나 DB에 부하
    - 확장성 : 사용자가 늘어나면 서버를 확장해야하는데, 세션이 저장되어 있는 서버로만 해당 요청이 가도록 분산처리를 해줘야해서 서버 확장이 어려움
        
        ( → 이때 분산처리 == **로드밸런싱** )
        
    - **💡** CORS : 세션 관리에 사용되는 토큰은 단일 도메인에서만 작동하도록 설계되어 CORS 방식을 사용할 때 관리가 어려움

### 토큰 기반 인증 방식

인증받은 사용자들에게 토큰 발급 → 서버에 요청시 헤더에 토큰을 함께 보내도록 함

✅ 세션과 다르게 상태를 유지하지 않기 때문에 **Stateless** 하다~

<img src="https://camo.githubusercontent.com/44466a9a74a4a2d470088091ecda82b2fe9c6bc9c368968580d584f94e88a578/68747470733a2f2f626c6f672e6b616b616f63646e2e6e65742f646e2f6f676f41672f62747141726979543573592f59597432776b457a35306b4b4e34376d4c775244584b2f696d672e706e67">

1. 사용자가 아이디와 비밀번호로 로그인
2. 서버측에서 사용자에게 유일한 토큰 발급
3. 클라이언트 측에서 전달받은 토큰을 쿠키나 스토리지에 저장, 서버에 요청할때마다 토큰을 요청 헤더에 담아 서버에 같이 전달
4. 서버는 토큰을 검증 후 요청에 응답
    
    ( 토큰 = 요청한 사람의 정보, 서버는 **DB 조회 없이 누군지 알아낼 수 있음** )
    
- 장점
    - Stateless 하며, 확장하기에 적합하다 ( ↔ 세션 기반 인증 )
    - **💡** CORS : 토큰을 이용한다면 어떤 디바이스, 도메인에서도 토큰 유효성 검사 가능

→ ✅ 최근에 많이 쓰이는 토큰 기반 인증 방식 ! **JWT** !

### JWT ( JSON Web Token )

인증에 필요한 정보들을 암호화한 JSON 기반 토큰

- 구조
    
    XXXXXX . YYYYYY . ZZZZZZ
    
    X → 헤더 : JWT에서 사용할 타입과 해시 알고리즘의 종류
    
    Y → 내용( Payload ) : 서버에서 첨부한 사용자 권한 정보 및 데이터
    
    Z → 서명 ( Signature ) : 인코딩된 Header + Payload → 비밀키로 해싱
    

⁉️ stateless 하다는 특징으로 클라이언트가 관리하기 때문에, 토큰을 탈취당하는 경우 대처가 어렵다

✅ 따라서 보안 전략 : Access Token / Refresh Token 으로 이중 인증방식

- **Access Token :** 실제 유저의 정보가 담긴 토큰
    - 대체로 유효기간이 짧다
- **Refresh Token** : access token 만료 시 새로 발급받기 위해 사용하는 토큰 ( DB 같이 저장 )
    - 대체로 유효기간이 길다
    
    > 흐름 )
    > 
    > 1. 회원가입 및 로그인
    > 2. access/refresh token 발급,  서버가 refresh token + 사용자 정보 같이 저장
    > 3.  access token 만료 
    > 4. 서버가 사용자 요청의 access token 만료를 확인 후 refresh token 요청
    > 5. 사용자 refresh token 전송
    >     1. 서버의 refresh token과 사용자의 token을 비교, 같으면 access token 재발
    >     2. refresh token까지 만료된 경우, 사용자 재로그인

# 4. CORS

Cross Origin Resource Sharing

⁉️ 서로 다른 도메인 간에 자원을 공유하는 것 , 기본적으로 차단되어있음

→ 여기서 origin 이란 **프로토콜 :// 호스트 : 포트**

EX ) https://localhost:8080, localhost:3000의 경우 포트가 다르기 때문에 CORS 에러 발생

프론트( 사용하고 있는 브라우저 등등 ) 을 믿지 못해서 request를 하지 못하도록 브라우저 쪽에서 막고 있는 것이다

✅ 해결방법 ?

== 서버에서 응답 헤더에 특정 헤더를 추가하는 방식으로 해결

( 합의 된 출처들 간에는 어떠한 기준을 충족 시키면 자원 공유를 합법적으로 허용해주자 )

- **Acess-Control-Allow-Origin : 특정 브라우저가 리소스에 접근 가능하도록 허용**
- Acess-Control-Allow-Method : 특정 HTTP Method만 리소스 접근 가능
- Acess-Control-Expose-Headers : 자바스크립트에서 헤더에 접근 가능
- credentials : 쿠키 등의 인증 정보 전달 가능

→ 서버에서 헤더에 위의 정보를 실어서 보내면, 

이후 브라우저가 둘을 비교하여 프론트가 보낸 출처 값이 서버의 답장 헤더에 담긴 Access-Control-Allow-Origin에 똑같이 있으면 안전한 요청으로 인정, 데이터 받아옴

- CORS의 종류
    - Simple Requeset : GET,PUT 등
        - request를 전부 다 보내고 통과를 못하면 답만 못 받아오는 것임
    - Preflight Request : POST, DELETE 등
        - 요청으로 인해 서버의 데이터가 변경되는 경우임
        - Preflight Request로 예비요청을 보내 안전한지 확인한 후, 허락이 떨어지면 본격적인 request가 가능함.

# 5. REST ( + REST API )

### REST 란?

REpresentational State Transfer

= 자원 ( Resource ) 의 표현 ( Representation ) 에 의한 상태 전달 ( State Transfer )

→ 자원을 정의하고 자원에 대한 주소를 지정하는 네트워크 아키텍처의 모음

- 구성요소
    1. 자원 : HTTP URI를 통해 자원을 명시하고
        
        > ⁉️ 여기서 자원이란?
        > 
        > 
        > ✅ 서버에 있는 ( DB에 들어가있는 ) 데이터 하나하나를 의미
        > 
        > URI를 통해 자원을 명시하고 구분할 수 있음
        > 
        > EX ) https://www.123rf.com/stock-photo/number_24.html
        > 
    2. 행위 : HTTP Method ( POST, GET, PUT.. )를 통해
    3. 내용 : 해당 자원( URI )에 대한 CRUD ( create, read, update, delete ) 적용

( + REST의 설계 원칙을 잘 지킨다 == RESTful 하다 ! )

### REST API

REST 원칙에 따라 설계된 API를 의미

( *API (Application Programming Interface) : 두 소프트웨어 애플리케이션이 서로 통신하고 데이터를 주고받을 수 있도록 하는 일련의 규칙 )

1. URI는 정보의 자원을 표현해야함
    1. /user, /reveiw 등등
2. 자원에 대한 행위는 HTTP Method( GET, POST .. ) 로 표현해야함.
    1. 행위는 URL에 포함하지 않음

# 5+. API Gateway

규모와 관계없이 API 생성, 유지 관리, 모니터링, 보호 등을 할 수 있게 해주는 서비스

클라이언트와 서버가 통신할 때 사용하는 많은 API들의 대문(=Gateway) 역할

= API가 지나가는 통로

---

### *MSA ( Micro Service Architecture )

: 독립적인 기능을 수행하는 작은 단위의 여러 서비스들로 구성된 아키텍처

EX ) 블로그 시스템 → 회원 서비스, 게시글 서비스  등등,,

- 회원가입 api, 로그인 api 등은 회원 서비스에서 처리
- 게시글 등록 api, 게시글 삭제 api 등은 게시글 서비스에서 처리

( 최근 실무에서 많이 사용되는 아키텍처 )

---

> ⁉️ 위와 같은 서비스가 50개, 100개가 되었을때 많은 서비스들의 앤드포인트를 관리하는 데에 어려움이 생김.
> 
> 
> 또한 , 서비스마다 인가인증 처럼 공통적으로 모두 가져야하는 기능을 중복으로 개발해야한다는 문제점이 발생함
> 

<img src="https://velog.velcdn.com/images%2Fjkijki12%2Fpost%2F27778d9d-4989-45b7-b282-11b3dcc54dbb%2Fcvbcvbcvbcvbcvbcvbcvbcvbcvbcvbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb.PNG">

> ✅
> 
> - API 게이트웨이를 등록해주면, 모든 클라이언트는 각 서비스의 엔드포인트 대신 API Gateway로 요청 전달
> - API Gateway가 설정에 따라 클라이언트 대신 각 엔드포인트로 요청을 하고, 응답을 클라이언트에게 다시 전달함 ( == 프록시 역할을 한다 ! )
> 
> → 클라이언트가 여러 백엔드 서비스에 접근할 수 있도록 **단일 진입점** 제공
> 
- 기능
    - 인증/인가
        
        <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FRPkXR%2FbtrREWSgyr7%2FAAAAAAAAAAAAAAAAAAAAAIJG_DqEFZPjn6voqxBvcppVmI-c5attrxzRFDKp1a-w%2Fimg.jpg%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1764514799%26allow_ip%3D%26allow_referer%3D%26signature%3D8DEJEAg6NgTpUUT07Xvv0wUW%252B2g%253D">
        
        : 모든 서비스마다 공통으로 구현이 필요함
        
        : API Gateway가 클라이언트 인증 정보를 받아 인증서버에게 전달하여 처리
        
    - **로드밸런싱**
        
        : 여러개의 API 서버로 부하를 분산하는 기능
        
        : 어떤 서버에 장애가 발생했을 때, 로드밸런싱 리스트에서 빼고, 복구완료 후 다시 넣는 기능
        
    
    …
    

# 6. 로드밸런싱

### 로드밸런서란?

: 서버나 장비의 트래픽을 분산하기 위해 사용하는 장비

위에서 언급했던 💡 스케일 아웃 ( 서버를 여러대 추가 ) 방법을 활용하기 위함

<img src="https://blog.kakaocdn.net/dna/cGA96g/btrA6PpTLFN/AAAAAAAAAAAAAAAAAAAAAMPKytv0hmPi01IJ5BBjHqiHUgHyZvKmlmNMxjCrhk-5/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1764514799&allow_ip=&allow_referer=&signature=iXT2G3dnH9A8nrR2MzYgxxC9wfA=">

- 로드밸런서의 업무

: 여러대의 백엔드 서버가 동작하더라도 사용자에게는 **하나의** **서비스** 처럼 ?!

 ✅ 로드밸런서가 대표 IP 주소를 가지고 클라이언트 요청을 받음 → 로드밸런서가 자신과 연결된 백엔드 서버의 실제 IP로 요청을 보냄

1. Service discovery : 현재 가능한 서버의 목록을 유지하고, 그 IP주소를 관리함
2. Health checking : 어떤 서버가 healthy( 요청을 처리할 수 있는지 )한지 확인
3. Load balancing : 각 유저의 요청을 특정 알고리즘을 이용해 healthy한 백엔드 서버들에게 나눠 네트워크를 분산시킴 !
- 장점
    - Naming abstraction
        
        : 클라이언트가 여러 백엔드 서버를 찾을 필요 없이, 로드밸런서만 알고있으면 로드밸런서가 찾고자하는 서버의 이름을 대신 찾아준다
        
    - Fault tolerance
        
        : 주기적으로 서버의 상태를 체크하고, 특정 서버에 장애가 발생한 경우 다른 서버에 요청을 전달하는 식으로 부하를 분산시킴.
        
    - 성능 개선
        
        : 여러대의 서버가 요청을 분산해서 받기 때문에 지연 시간을 줄일수 있음
        

### L7계층 로드밸런서

: 애플리케이션 계층에서 작동하는 로드밸런서

- 주로 HTTP, HTTPS 를 기반으로 클라이언트-서버 간의 트래픽을 분산
- 요청내용 ( URL, 헤더, 쿠키 ) 등을 기반으로 로드 밸런싱
- 장점 : 다양한 기능 및 유연성 제공
    - 요청내용을  분석하여 특정 서버로 전달하거나, 캐싱, 압축 등 구현 가능
- 단점 : 처리 속도가 느림 → 패킷의 L7 정보를 분석해야하기 때문

→ 웹 서비스, **API 게이트웨이**, CDN 등 L7의 로드 밸런싱이 필요한 서비스

---

**💡 CDN ( Content Delivery Network : 콘텐츠 전송 네트워크 )** 

: 전 세계에 분산된 서버 네트워크를 통해 웹 콘텐츠 ( 이미지,동영상 )를 사용자 기준 가장 가까운 서버에서 전송하여 속도를 높이는 기술

---

### vs L4계층 로드밸런서

: 전송 계층에서 작동하는 로드밸런서

- 주로 TCP, UDP 를 기반으로 클라이언트-서버 간의 트래픽을 분산
- 클라이언트의 IP주소, 포트 /  서버의 IP주소, 포트를  기반으로 로드 밸런싱
- 장점 : 응답 속도가 빠름 → 패킷의 헤더 정보만 이용하기 때문에
- 단점 : L7의 정보를 활용하지 못해 기능이 제한적임

→ 온라인 게임, 스트리밍 서비스 등 **실시간 트래픽 처리**가 중요한 서비스

# ⁉️ 예상 질문 모음

> **✅ 기술 면접 답변틀**
> 
> 1. 기술의 정의 
> 2. 어디에서 사용하는지
> 3. 어떻게 사용할 수 있는지

<aside>
💡

HTTP 프로토콜에 대해 설명해주세요.

HTTP 프로토콜이 가진 특성을 몇가지 설명해보세요.

HTTP와 HTTPS의 차이점은 무엇인가요?

HTTP Method GET 과 POST 메소드를 설명해보세요.

PUT 메서드와 PATCH 메서드의 차이점에 대해 설명해주세요.

www.naver.com 브라우저에 접속하는 과정을 설명해보세요.

공인 IP와 사설 IP에 대해서 설명해보세요.

REST API를 담당 구현하셨다고 적으셨는데, REST가 무엇인지 설명해보세요.

CORS에 대해 설명해주세요

→ 터미널에서 curl과 같은 도구를 사용하거나 postman 같은 도구를 이용해 백엔드 서버에 요청을 보내면 CORS로 막을 수 있나요?

→ CORS 프리플라이트(Preflight) 요청은 무엇인가요?

브라우저 저장소에 대해서 설명해주세요.

쿠키와 세션의 차이점은 무엇인가요?

세션 기반 인증과 토큰 기반 인증의 차이점과 각각 어느 경우에 적합한 지 설명하세요.

</aside>
