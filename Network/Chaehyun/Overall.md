## OSI 7계층

<img width="721" height="364" alt="image" src="https://github.com/user-attachments/assets/c9001c22-0ba4-4e15-848b-99be3b1646d9" />


- 국제 표준화기구에서 여러 통신 업체들의 장비 호환성을 위해 발표 (1984)
- 계층을 나눈 이유: 통신이 일어나는 과정이 단계별로 파악할 수 있기 때문

### Layer 1. 물리계층 (Physical Layer)

> 데이터를 전기 신호로 바꾸어주는 계층

- 최하위 계층
- 0과 1의 `비트`열 → On, Off의 전기적 신호 상태로 데이터 전달
- PDU : 비트(Bit)
- 프로토콜 : Modem, Cable, Fiber, RS-232C
- 장비 : 허브, 리피터

### Layer 2. 데이터링크 계층 (Data-Link Layer)

> 데이터의 물리적인 전송과 에러 검출, 흐름 제어를 담당하는 계층
> 
- 물리적인 연결을 통하여 인접한 두 장치 간의 신뢰성 있는 정보 전송을 담당
- 통신에서의 오류도 찾아주고, 오류가 있다면 데이터를 재전송하는 기능
- Point-To-Point 전송
- MAC 주소 통해서 통신
- PDU : 프레임(Frame)
- 프로토콜 : 이더넷, MAC, PPP, ATM, LAN, Wifi
- 장비 : 브릿지, 스위치

### Layer 3. 네트워크 계층 (Network Layer)

> 패킷을 목적지까지 가장 빠른 길로 전송하기 위한 계층
> 
- 중계 노드를 통하여 전송하는 경우 어떻게 중계할 것인가를 규정
- 라우팅 기능을 맡고 있는 계층
- 목적지까지 가장 안전하고 빠르게 데이터를 보내는 기능
    - 최적의 경로 설정 가능
- PDU : 패킷(Packet)
- 프로토콜 : IP, ICMP 등
- 장비 : 라우터, L3 스위치

### Layer 4. 전송 계층 (Transport Layer)

> 최종 수신 프로세스로 데이터의 전송을 담당하는 계층
> 
- 종단 간 신뢰성 있고 정확한 데이터 전송을 담당
- 송신자와 수신자 간의 신뢰성있고 효율적인 데이터를 전송하기 위하여 오류검출 및 복구, 흐름제어와 중복검사 등을 수행
- 쪼개져 있는 데이터들을 원래대로 합쳐서 보내는 역할을 담당
    - 송신측에서 받은 데이터가 수신측까지 손실 없이 전송되었는지 여부 확인
    - 데이터를 전송할 때 헤더에 송/수신지 포트번호를 포함하여 전송
- PDU : 세그먼트(Segment)
- 프로토콜 : TCP, UDP , ARP, RTP
- 장비 : 게이트웨이, L4 스위치

### Layer 5. 세션 계층 (Session Layer)

> 컴퓨터끼리 통신을 하기 위해 세션을 만드는 계층
> 
- 통신 장치 간 상호작용 및 동기화를 제공
- 연결 세션에서 데이터 교환과 에러 발생 시의 복구를 관리
- 네트워크상 양쪽 연결을 관리하고 연결을 지속
- 운영체제가 통신을 하기 위한 세션 확립/유지/중단 과정 해줌
- 프로토콜 : NetBIOS, SSH, TLS

### Layer 6. 표현 계층 (Presentation Layer)

> 데이터 형식을 정의하는 계층 (코드 간의 번역)
> 
- 송신자에서 온 데이터를 해석하기 위한 응용계층 데이터 부호화, 변화 (인코딩)
- 수신자에서 데이터의 압축을 풀 수 있는 방식으로 된 데이터 압축
- 데이터의 암호화와 복호화 (디코딩)
    
    MIME 인코딩이나 암호화 등의 동작이 표현계층에서 이루어짐
    
    ex) EBCDIC로 인코딩된 파일을 ASCII로 인코딩된 파일로 바꿔줌
    
- 프로토콜 : JPG, MPEG, SMB, AFP

### Layer 7. 응용 계층 (Application Layer)

> 사용자에게 통신을 위한 서비스 제공. 인터페이스 역할
> 
- 응용 프로세스 간의 정보 교환을 담당
- 사용자에게 보이는 유일한 계층. 메일 전송, 인터넷 접속 등의 작업을 수행
- 프로토콜 : DHCP, DNS, FTP, HTTP

## TCP/IP 모델

- 인터넷 프로토콜 스택은 대부분 TCP/IP를 ㄸ름
- 인터넷 프로토콜 중 가장 중요한 역할을 하는 `TCP`와 `IP`의 합성어로 데이터의 흐름 관리, 정확성 확인, 패킷의 목적지 보장을 담당
- **데이터의 정확성 확인은 TCP가, 패킷을 목적지까지 전송하는 일은 IP가 담당**
<img width="437" height="184" alt="image" src="https://github.com/user-attachments/assets/c0ade383-7fc1-4757-9a01-2d8885218284" />


- 데이터 캡슐화
    - 단계별로 헤더(Data **→** Segment **→** Datagram **→** Frame)를 붙여 전송
    
    <img width="540" height="320" alt="image" src="https://github.com/user-attachments/assets/898e6e67-4ce2-48e2-804f-852314a8a3cb" />

    

## [www.google.com](http://www.google.com) 시나리오

> 브라우저 주소창에 [www.google.com](https://www.google.com/)을 입력하고 엔터를 쳤을 때 일어나는 일
**DNS**(L7) -> **HTTP**(L7) -> **TCP**(L4) -> **IP**(L3) -> **MAC**(L2)으로 이어지는 전 과정
> 

<img width="2048" height="1062" alt="image" src="https://github.com/user-attachments/assets/73cce76f-81a7-4954-bfbb-61b904f6e1aa" />


### L7. DNS - 이름 해석

- 상황: 브라우저는 `www.google.com`이라는 *이름*은 알지만, 실제 통신을 위한 *IP 주소* (예: `172.217.14.228`)는 모르고 있음
- 액션
    1. 브라우저가 자신의 로컬 캐시를 확인
    2. 없으면 OS에게 물어봄 → OS도 자체 캐시를 확인 (hosts 파일 등)
    3. 없으면 OS는 로컬 DNS 리졸버에게 "[www.google.com](https://www.google.com/)의 IP 주소 알려줘"라고 쿼리를 보냄
    4. 리졸버는 쿼리를 받아 캐시가 없다면
    Root DNS 서버부터 시작해서 .com을 관리하는 TLD 서버, google.com을 관리하는 신뢰할 수 있는 네임 서버까지 차례로 물어보는 **재귀적 쿼리(Recursive Query)**를 실행
- 결과: 리졸버가 [google.com](http://google.com) 의 IP 주소를 알아내서 브라우저에게 전달

**⇒ 브라우저는 목적지 IP 주소를 알게 됨!!!**

### L4. TCP 3-Way Handshake - 전화걸기

- 상황: IP 주소는 알지만, HTTP 요청이라는 데이터를 보내기 전에 먼저 서버와 안정적인 ‘통신 회선’을 열어야 함 → 이 역할을 TCP가 함
- 액션: 브라우저(클라이언트)가 구글 서버로 3-Way Handshake 시작
    1. Client → Server: “연결하고 싶어” (SYN 패킷 전송)
    2. Server → Client: “준비됐어” (SYN+ACK 패킷 응답)
    3. Client → Server: “시작하자” (ACK 패킷 전송)
- 결과: 양측 간에 신뢰할 수 있는 TCP연결(세션)이 수립

### L7. HTTP - 용건 말하기

- 상황: 안정적인 회선(TCP)이 열림. 브라우저는 이 회선을 통해 “구글 홈페이지 보여줘”라는 실제 요청을 보냄
- 액션
    
    브라우저가 다음과 같은 HTTP 요청 메시지
    
    ```jsx
    GET / HTTP/1.1
    Host: www.google.com
    User-Agent: (브라우저 정보...)
    ... (기타 헤더들)
    ```
    

### L4 → L3 → L2. 캡슐화 - 데이터 포장

- 상황: HTTP 요청 데이터를 목적지(구글 서버)로 보내야 함. 각 계층을 내려가면서 포장
- 액션
    1. **(L4) 전송 계층:** HTTP 메시지(데이터)는 **TCP 세그먼트**로 쪼개지고, 여기에 **TCP 헤더**가 붙음
    (여기에는 출발지/목적지 *포트 번호*가 포함됨. HTTP는 보통 80, HTTPS는 443번 포트)
    2. **(L3) 네트워크 계층:** TCP 세그먼트는 **IP 패킷**으로 포장디고 여기에 **IP 헤더**가 붙음
    (여기에 출발지 IP와 1단계에서 알아낸 목적지 *IP 주소*가 포함)
    3. **(L2) 데이터링크 계층:** IP 패킷은 **이더넷 프레임**으로 포장되고 여기에 **이더넷 헤더**가 붙음 
    (여기에 출발지 MAC과 목적지 *MAC 주소*가 포함)

### L1. 데이터 전송

- 상황: 모든 캡슐화가 끝난 이더넷 프레임이 준비됨
- 액션
    1. 이 프레임은 L1으로 전달
    2. 데이터(비트열)가 랜카드에 의해 전기 신호로 변환
    3. 랜선을 타고 라우터로 정송

### L3. 라우팅

- 상황: 내 컴퓨터가 보낸 프레임(전기 신호)이 라우터에 도착
- 액션
    1. 라우터는 L2(데이터링크 계층)의 장비이므로, 이더넷 프레임을 엶
    2. 라우터는 L3(네트워크 계층)의 장비이기도 하므로, 그 안의 IP 패킷을 엶
    3. IP 헤더에 적힌 **'최종 목적지 IP 주소'** (구글 서버 IP)를 확인
    4. 라우터는 자신이 가진 '라우팅 테이블'을 보고, 이 패킷을 구글 서버로 보내려면 그다음 어느 라우터로 보내야 할지 최적의 경로를 결정
    5. 라우터는 이 IP 패킷을 **새로운 L2 프레임으로 다시 포장**합니다. 
    (이때 출발지 MAC은 *내 라우터*, 목적지 MAC은 *인터넷상의 다음 라우터)*
- 결과: 인터넷의 수많은 라우터들을 거치며 반복

### L2~L7. 서버 도착 및 응답

- **상황:** 마침내 패킷이 구글 서버의 네트워크에 도착
- **액션:**
    1. 구글 서버는 받은 데이터를 L1 -> L2 -> L3 -> L4 -> L7 순서로 캡슐화를 품(역캡슐화).
    2. L7(응용 계층)에 도달하면, 드디어 "GET / HTTP/1.1 ..."라는 브라우저의 HTTP 요청을 읽음
    3. 서버는 이 요청에 맞는 응답(구글 홈페이지의 HTML, CSS, JavaScript 파일 등)을 준비
    4. 서버는 이 응답 데이터를 다시 **L7 -> L1 방향으로 캡슐화**
    (이번엔 서버가 출발지, 내 컴퓨터가 목적지)
    5. 이 응답 패킷이 인터넷 라우터들을 거쳐 다시 내 컴퓨터로 전송

### L7. 렌더링

- **상황:** 구글 서버가 보낸 응답 패킷이 내 컴퓨터에 도착
- **액션:**
    1. 내 컴퓨터도 L1 -> L7 순서로 역캡슐화를 진행
    2. L7(응용 계층)에서 브라우저가 HTTP 응답(HTML 등) 받음
    3. **렌더링 엔진**이 이 HTML을 해석해서 우리가 보는 `www.google.com` 웹페이지 화면을 그려줌
